use crate::{
    operator_ext::RasterOperatorExt,
    raster_type::RasterType,
    source::{BoxedRasterOperatorInstance, CreateUnaryOperator, RasterSource},
    CreateBinaryOperator, CreateBinaryOperator2,
};

/// An Enum to indicate what a RasterOperator produces. TODO: find out what kind of combinations we need!
#[derive(Debug, Clone)]
pub enum RasterCreates {
    /// Upgrades a RasterType of a selected source: U8 -> U16
    UpgradesInput(usize),
    /// Downpgrades a RasterType of a selected source: U16 -> U8
    DowngradesInput(usize),
    // The same as a specified input
    SameAsInput(usize),
    // A concrete Type
    ConceteType(RasterType),
}

/// An Enum to indicate what a RasterOperator requires at an input.
#[derive(Debug, Clone)]
pub enum RasterWants {
    /// accepts any input
    Any,
    /// requries a specific Input
    ConceteType(RasterType),
    /// no input
    None,
}

/// The MetaRasterOperator is a trait for MetaOperators creating RasterOperators for processing Raster data
#[typetag::serde(tag = "type")]
pub trait MetaRasterOperator {
    /// The magic method to handle the mapping of the create type to a concrete implementation. More work required! TODO: macro?
    fn create_raster_op(&self) -> BoxedRasterOperatorInstance {
        println!("MetaRasterOperator: create_raster_op");
        match self.creates_type() {
            RasterCreates::ConceteType(ct) => match ct {
                RasterType::U8 => BoxedRasterOperatorInstance::U8(self.create_u8_raster_op()),
                RasterType::U16 => BoxedRasterOperatorInstance::U16(self.create_u16_raster_op()),
            },
            _ => panic!(),
        }
    }

    /// there is no way to use generics for the MetaRasterOperators in combination with serialisation -_-. We need to implement the create operator methods. TODO: Macro?
    fn create_u8_raster_op(&self) -> Box<dyn RasterSource<RasterType = u8>>;
    /// there is no way to use generics for the MetaRasterOperators in combination with serialisation -_-. We need to implement the create operator methods. TODO: Macro?
    fn create_u16_raster_op(&self) -> Box<dyn RasterSource<RasterType = u16>>;

    /// get the type the Operator creates.
    fn creates_type(&self) -> RasterCreates;
    /// get the types the operator generates.
    fn requires_type(&self) -> &[RasterWants];

    /// get the sources of the Operator. TODO: extra trait?
    fn raster_sources(&self) -> &[Box<dyn MetaRasterOperator>];
    //fn raster_sources(&self) -> &[&dyn MetaRasterOperator];
}

pub trait AutoGenerateDynUnaryCombos: MetaRasterOperator {
    fn auto_create_u8_raster_op<'a, O>(&self) -> Box<dyn RasterSource<RasterType = u8> + 'a>
    where
        O: 'a
            + RasterSource<RasterType = u8>
            + CreateUnaryOperator<Box<dyn RasterSource<RasterType = u8>>, String>,
    {
        println!("MetaPlusOneOperator: create_u8_raster_op");
        let s = self.raster_sources()[0]
            .create_raster_op()
            .as_u8()
            .expect("not u8");
        O::create::<u8>(s, "params".to_string()).boxed_raster()
    }

    fn auto_create_u16_raster_op<'a, O>(&self) -> Box<dyn RasterSource<RasterType = u16> + 'a>
    where
        O: 'a
            + RasterSource<RasterType = u16>
            + CreateUnaryOperator<Box<dyn RasterSource<RasterType = u16>>, String>,
    {
        println!("MetaPlusOneOperator: create_u16_raster_op");
        let s = self.raster_sources()[0]
            .create_raster_op()
            .as_u16()
            .expect("not u16");

        O::create::<u16>(s, "params".to_string()).boxed_raster()
    }
}

pub trait AutoGenerateDynBinaryCombos: MetaRasterOperator {
    fn auto_create_u8_raster_op<O>(&self) -> Box<dyn RasterSource<RasterType = u8> + 'static>
    where
        O: CreateBinaryOperator2<String> + 'static,
    {
        println!("MetaPlusOneOperator: create_u8_raster_op");
        let source_a = self.raster_sources()[0].create_raster_op();
        let source_b = self.raster_sources()[1].create_raster_op();
        match (source_a, source_b) {
            (BoxedRasterOperatorInstance::U8(a), BoxedRasterOperatorInstance::U8(b)) => {
                O::create_from_boxes::<u8, u8>(a, b, "params".to_string()).boxed_raster()
            }
            _ => panic!(),
        }
    }

    fn auto_create_u16_raster_op<O>(&self) -> Box<dyn RasterSource<RasterType = u16> + 'static>
    where
        O: CreateBinaryOperator2<String> + 'static,
    {
        println!("MetaPlusOneOperator: create_u8_raster_op");
        let source_a = self.raster_sources()[0].create_raster_op();
        let source_b = self.raster_sources()[1].create_raster_op();
        match (source_a, source_b) {
            (BoxedRasterOperatorInstance::U16(a), BoxedRasterOperatorInstance::U8(b)) => {
                O::create_from_boxes::<u16, u8>(a, b, "params".to_string()).boxed_raster()
            }
            (BoxedRasterOperatorInstance::U8(a), BoxedRasterOperatorInstance::U16(b)) => {
                O::create_from_boxes::<u16, u8>(b, a, "params".to_string()).boxed_raster()
            }
            (BoxedRasterOperatorInstance::U16(a), BoxedRasterOperatorInstance::U16(b)) => {
                O::create_from_boxes::<u16, u16>(a, b, "params".to_string()).boxed_raster()
            }
            _ => panic!(),
        }
    }
    /*
    fn create_u8_u8<O>(
        &self,
        a: Box<dyn RasterSource<RasterType = u8>>,
        b: Box<dyn RasterSource<RasterType = u8>>,
    ) -> Box<dyn RasterSource<RasterType = u8>>
    where
        O: 'static
            + CreateBinaryOperator<
                Box<dyn RasterSource<RasterType = u8>>,
                Box<dyn RasterSource<RasterType = u8>>,
                String,
            >
            + RasterSource<RasterType = u8>,
    {
        O::create::<u8, u8>(a, b).boxed_raster()
    }
    */
}
